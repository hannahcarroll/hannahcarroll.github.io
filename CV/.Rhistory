varpi <- NULL
eps <- NULL
ecc <- NULL
for (i in names(orbit)) assign(i,orbit[[i]])
nu <- long - varpi
rho <- (1-ecc^2)/(1+ecc*cos(nu))
sindelta <- sin(eps)*sin(long)
cosdelta <- sqrt(1-sindelta^2)
sinlatsindelta <- sin(lat)*sindelta
coslatcosdelta <- cos(lat)*cosdelta
if (is.null(H))
{
cosH0 <- min(max(-1,-sinlatsindelta/coslatcosdelta),1)
sinH0 <- sqrt(1-cosH0^2)
H0 <- acos(cosH0)
insol <- S0/(pi*rho^2)*(H0*sinlatsindelta+coslatcosdelta*sinH0)
}
else
{
insol <- max(0, S0/(rho^2)*(sinlatsindelta+coslatcosdelta*cos(H)))
}
return(insol)
}
## time increment corresponding a tsl increment
.dtdnu <- function (orbit,long=pi/2)
{
nu <- long - orbit['varpi']
ecc <- orbit['ecc']
xec <- ecc*ecc
rho <- (1-xec)/(1+ecc*cos(nu))
.dtdnu <- rho^2/sqrt(1.-xec)
}
## caloric_insolation
## integrated insolation over the 180 days receiving above median insolation
calins <- function (orbit,lat=65*pi/180,...)
{
ins   <- sapply(seq(1:360)*pi/180, function(x) Insol(orbit,long=x, lat=lat,...))
dt    <- sapply(seq(1:360)*pi/180, function(x) .dtdnu (orbit,long=x))
is    <- sort(ins,decreasing=TRUE,index.return=TRUE)$ix
cs    <- cumsum(dt[is])
is    <- which(cs <= 180)           ## the 180 days whose cumulative length is half total
## year length, picking days by decreasing order of
## insolation.
XCORR = 86.4 *  YEAR / 360
sum(ins[is]*dt[is])* XCORR    ## result in kJ
}
## integrated insolation over the 360 days receiving insolation above a threshold
thrins <- function (lat=65*pi/180,orbit,threshold=400,...)
{
ins   <- sapply(seq(1:360)*pi/180, function(x) Insol(orbit,long=x, lat=lat,...))
dt    <- sapply(seq(1:360)*pi/180, function(x) .dtdnu (orbit,long=x, ...))
is    <- which(ins >= threshold)
XCORR = 86.4 *  YEAR / 360
sum(ins[is]*dt[is])* XCORR   ## result in kJ
}
## time-integrated between two true solar longitude bounds
Insol_l1l2 <- function (orbit,l1=0,l2=2*pi,lat=65*pi/180,avg=FALSE,ell=TRUE,...)
{
# parameters: orbit : supplied by orbit calculator; e.g. : ber78 or ber90
# l1 and l2 : longitudes bonds in radiants. Defaults to annual average.
# discretize longitude intreval in N intervals
# avg : supplies an average insolation
# ell : defaults to TRUE, use elliptic integrals for calculation (much faster)
#       rather than trapeze rule integral.  Currently incompatible
#       with avg=TRUE (this can be fixed later)
if (ell &&  requireNamespace("gsl", quietly = TRUE))
## use elliptic integrals if required and available
{
if (l1 < l2)
{
INT = W(lat, orbit['eps'], orbit['ecc'],l2,...) -
W(lat, orbit['eps'], orbit['ecc'], l1,...)}
else
{
INT = W(lat, orbit['eps'], orbit['ecc'], 2*pi,...) -
W(lat, orbit['eps'], orbit['ecc'], l1,...) +
W(lat, orbit['eps'], orbit['ecc'], l2,...)
}
if (avg) {
DT <- l2day(orbit,l2) - l2day(orbit,l1)
if (DT <= 0) DT = DT+360.
XCORR = 86.4 *  YEAR / 360
INT = INT / (DT*XCORR) ## result in W/m2
}
}
else
## integration using trapeze rule
{
Dl = ((l2-l1) %% (2*pi))
if (Dl == 0) Dl=2*pi
N =  1*ceiling(Dl* 180/pi)
dl = Dl/N
L  = l1+(0:N)*dl
ins   <- sapply(L, function(x) Insol(orbit=orbit,long=x, lat=lat,...))
dt    <- sapply(L, function(x) .dtdnu (orbit=orbit,long=x)) * 180./pi
is    <- ins*dt
XCORR = 86.4 *  YEAR / 360
INT = (sum(is[2:N]) +  0.5 *is[1] +  0.5 *is[N+1]) * dl * XCORR  ## result in kJ
if (avg) {
DT =  (sum(dt[2:N]) + 0.5 * dt[1] + 0.5 * dt[N+1]) * dl * XCORR
INT = INT / DT ## result in W/m2
}
}
INT
}
day2l  <- function (orbit,day)
{
## converts day to longitude.
## source : Berger 78, from Brower and Clemence.
## day using a 360-d calendar
## here :  day of spring equinox is in fact conventionally 80
ecc = orbit['ecc']
varpi= orbit['varpi']
# definitions for speed-up
xee= ecc*ecc
xec = xee * ecc
xse= sqrt(1.-xee)
# true anomaly of vernal equinox point
xlp= - varpi
# mean anomaly  of the vernal equinox point
lm =  xlp - 2.*((ecc/2 + xec/8)*(1+xse)*sin(xlp) -
xee/4*(0.5+xse)*sin(2*xlp) +
xec/8*(1/3+xse)*sin(3*xlp) )
# mean anomaly  of the point considered
M = (day- 80) * pi/ 180. + lm
# TRUE anomaly of the point considered
V = M + (2*ecc-xec/4.)*sin(M) +
5/4*xee*sin(2*M) +
13/12*xec*sin(3*M)
# TRUE longitude of the point considered
L = ( V + varpi ) %% (2*pi)
L
}
l2day <- function (orbit,l)
## converts true solar longitude to day
## source :  Brouwer and Clemence
{
ecc = orbit['ecc']
varpi= orbit['varpi']
# definitions for speed-up
xee= ecc*ecc
xec = xee * ecc
xse= sqrt(1.-xee)
# true anomaly
xlp= - varpi
# mean anomaly  of the vernal equinox point
lm =  xlp - 2.*((ecc/2 + xec/8)*(1+xse)*sin(xlp) -
xee/4*(0.5+xse)*sin(2*xlp) +
xec/8*(1/3+xse)*sin(3*xlp) )
# true anomaly of the point considered
V = (l + xlp) %% (2*pi)
# mean anomaly  of the point considered
M =  V - 2.*((ecc/2 + xec/8)*(1+xse)*sin(V) -
xee/4*(0.5+xse)*sin(2*V) +
xec/8*(1/3+xse)*sin(3*V) )
# anomaly in deg. elapsed between vernal equinox point and point
DAY = ( 80 + (M - lm)  * 360.0/(2*pi) ) %% (360.0)
DAY
}
date_of_perihelion <- function(orbit)
{
ecc = orbit['ecc']
varpi= orbit['varpi']
# definitions for speed-up
xee= ecc*ecc
xec = xee * ecc
xse= sqrt(1.-xee)
# true anomaly
xlp= - varpi
# mean anomaly  of the vernal equinox point
lm =  xlp - 2.*((ecc/2 + xec/8)*(1+xse)*sin(xlp) -
xee/4*(0.5+xse)*sin(2*xlp) +
xec/8*(1/3+xse)*sin(3*xlp) )
# mean anomaly  of the point considered
M =  0.
# anomaly in deg. elapsed between vernal equinox point and perihelion passage
DAY = ( 80 + (M - lm)  * 360.0/(2*pi) ) %% (360.0)
names(DAY) <- 'day'
DAY
}
Insol_d1d2 <- function (orbit,d1,d2,lat=65*pi/180,avg=FALSE,...)
## as insol but given days rather than longitudes
{
l1 = day2l(orbit,d1)
l2 = day2l(orbit,d2)
Insol_l1l2(orbit,lat=lat,l1,l2,avg=avg,...)
}
Milankovitch <- function(orbit, S0=1365, lat=seq(-pi/2, pi/2, l=73), long=seq(0, 2*pi, l=145), deg=TRUE)
{
# returns a 'Milankovitch graph' of incoming solar irradiance
CONVERT=ifelse(deg, 180/pi, 1)
long = long[-length(long)]
M <- outer(long,lat,Vectorize(Insol,c("long","lat")),orbit=orbit,  S0=S0)
attr(M,  "class") <- 'Milankovitch'
attr(M,  "lat") <- lat * CONVERT
attr(M,  "long") <- long * CONVERT
attr(M,  "deg") <- deg
M
}
plot.Milankovitch <- function(x, months=TRUE, plot_function=image,...)
{
long = attr(x, "long")
if( ! attr(x,  "deg"))
{stop ('plot Milankovitch only when longitude in degrees')
}
if (months)
{
Col  = c(which(long >= (360-80)) , which(long < (360-80)))
Col = c(Col, Col[1])
Long = c(long, long[1]+360)
MM = x[ Col,]
plot_function(Long, attr(x, "lat"), MM, axes=FALSE,xlab='Month',ylab='Latitude',xaxs='i',yaxs='i',...)
if(!exists("legend.only"))  {
axis (1, at=seq(0,12)*30, labels=rep('',13))
axis (3, at=seq(0,12)*30, labels=rep('',13))
axis (1, at=seq(0,11)*30+15, labels=c('J','F','M','A','M','J','J','A','S','O','N','D'), tick=FALSE)}
}
else
{   plot_function(attr(x, "long"), attr(x, "lat"), x, axes=FALSE,
xlab='True solar Longitude',ylab='Latitude',xaxs='i',yaxs='i',...)
if(!exists("legend.only"))
{axis (1, at=seq(0,360,30))
axis (3, at=seq(0,360,30))
}
}
if(!exists("legend.only"))
{
axis(2, at=seq(-90,90,30), labels=c('90S','60S', '30S','Eq.','30N','60N','90S'))
axis(4, at=seq(-90,90,30), labels=rep('',7))
}
}
plot.Milankovitch(4)
plot.Milankovitch(4.0)
plot.Milankovitch(x=4.0)
Insol(4)
Milankovitch()
long <- 4.0
Milankovitch()
Milankovitch(long = long)
plot.Milankovitch(x=long)
long
plot.Milankovitch(long)
library(asnipe)
# List of the packages you need
packages <- c("ggmap", "sp", "rgdal", "rgeos", "maptools", "viridis", "ggplot2", "maps", "raster")
# Which ones are new to your machine?
new.packages <- packages[!(packages %in% installed.packages()[,"Package"])]
# If they're new, install them
if(length(new.packages)) install.packages(new.packages)
# Now load all required packages into memory
lapply(packages, library, character.only = TRUE)
# Now load all required packages into memory
apply(packages, library, character.only = TRUE)
# List of the packages you need
packages <- c("ggmap", "sp", "rgdal", "rgeos", "maptools", "viridis", "ggplot2", "maps", "raster")
# Which ones are new to your machine?
new.packages <- packages[!(packages %in% installed.packages()[,"Package"])]
# If they're new, install them
if(length(new.packages)) install.packages(new.packages)
# Now load all required packages into memory
lapply(packages, library, character.only = TRUE)
# Set your working directory to the source file location
this.dir <- dirname(parent.frame(2)$ofile)
# Set your working directory to the source file location
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
if (!file.exists("./ia_eco_l4/ia_eco_l4.shp")){
download.file(file.path('ftp://newftp.epa.gov/EPADataCommons/ORD/Ecoregions/ia/ia_eco_l4.zip'),
f <- tempfile())
unzip(f, exdir = "./ia_eco_l4")
rm(f)
}
plot(cars)
# Set your working directory to the source file location
setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
# List of the packages you need
packages <- c("ggmap", "sp", "rgdal", "rgeos", "maptools", "viridis", "ggplot2", "maps", "raster")
# Which ones are new to your machine?
new.packages <- packages[!(packages %in% installed.packages()[,"Package"])]
# If they're new, install them
if(length(new.packages)) install.packages(new.packages)
# Now load all required packages into memory
lapply(packages, library, character.only = TRUE)
iowa.regions <- readOGR(dsn=getwd(), layer="./ia_eco_l4/ia_eco_l4.shp")
iowa.regions <- readOGR(dsn=getwd(), layer="./ia_eco_l4/ia_eco_l4")
iowa.regions <- readOGR(dsn=getwd(), layer="ia_eco_l4")
iowa.regions <- readOGR(dsn="./ia_eco_l4/", layer="ia_eco_l4")
if (!file.exists("./ia_eco_l4/ia_eco_l4.shp")){
download.file(file.path('ftp://newftp.epa.gov/EPADataCommons/ORD/Ecoregions/ia/ia_eco_l4.zip'),
f <- tempfile())
unzip(f, exdir = getwd())
rm(f)
}
iowa.regions <- readOGR(dsn=getwd(), layer="ia_eco_l4")
if (!file.exists("./ia_eco_l4.shp")){
download.file(file.path('ftp://newftp.epa.gov/EPADataCommons/ORD/Ecoregions/ia/ia_eco_l4.zip'),
f <- tempfile())
unzip(f, exdir = getwd()) # This unzips the file to your working directory
rm(f)
}
iowa.regions <- readOGR(dsn=getwd(), layer="ia_eco_l4")
plot(iowa.regions)
iaregions.df <- as.data.frame(iowa.regions)
ggplot() + theme_void() +
geom_polygon(data=fortify(iowa.regions), aes(x=long, y=lat, group=group), colour="grey68", fill="grey95")
ggplot() + theme_void() +
geom_polygon(data=fortify(iowa.regions), aes(x=long, y=lat, group=group, fill=US_L4NAME), colour="grey68") +
scale_fill_viridis_d()
View(iowa.regions)
iowa.regions@data[["US_L4NAME"]]
ggplot() + theme_void() +
geom_polygon(data=fortify(iowa.regions), aes(x=long, y=lat, group=group, fill=iowa.regions@data[["US_L4NAME"]]), colour="grey68") +
scale_fill_viridis_d()
# Create points for ecoregions
iowa.regions@data$id <- rownames(iowa.regions@data)
iowa.regions.points <- fortify(iowa.regions, region="id")
# Did it work?
is.data.frame(iowa.regions.points)
# Join
iowa.regions.df <- merge.data.frame(iowa.regions.points, iowa.regions@data, by="id")
# Note that fortify is no longer needed because we're working with a data frame
ggplot() + theme_void() +
geom_polygon(data=iowa.regions, aes(x=long, y=lat, group=group, fill=US_L4CODE), colour="grey68") +
scale_fill_viridis_d()
ggplot() + theme_void() +
geom_polygon(data=iowa.regions.df, aes(x=long, y=lat, group=group, fill=US_L4CODE), colour="grey68") +
scale_fill_viridis_d()
ggplot() + theme_void() +
geom_polygon(data=iowa.regions.df, aes(x=long, y=lat, group=group, fill=US_L4NAME), colour="grey68") +
scale_fill_viridis_d(name="Level IV Ecoregions")
ggplot() + theme_void() +
geom_polygon(data=iowa.regions.df, aes(x=long, y=lat, group=group, fill=US_L4NAME), colour="grey68") +
scale_fill_viridis_d(name="Level IV Ecoregions") + coord_cartesian()
ggplot() + theme_void() +
geom_polygon(data=iowa.regions.df, aes(x=long, y=lat, group=group, fill=US_L4NAME), colour="grey68") +
scale_fill_viridis_d(name="Level IV Ecoregions") + coord_quickmap()
projection(iowa.regions)
ggplot() + theme_void() +
geom_polygon(data=iowa.regions.df, aes(x=long, y=lat, group=group, fill=US_L4NAME), colour="grey68") +
scale_fill_viridis_d(name="Level IV Ecoregions") + coord_map(projection = projection(iowa.regions))
??projection
ggplot() + theme_void() +
geom_polygon(data=iowa.regions.df, aes(x=long, y=lat, group=group, fill=US_L4NAME), colour="grey68") +
scale_fill_viridis_d(name="Level IV Ecoregions") + coord_map()
ggplot() + theme_void() +
geom_polygon(data=iowa.regions.df, aes(x=long, y=lat, group=group, fill=US_L4NAME), colour="grey68") +
scale_fill_viridis_d(name="Level IV Ecoregions") + coord_map()
ggplot() + theme_void() +
geom_polygon(data=iowa.regions.df, aes(x=long, y=lat, group=group, fill=US_L4NAME), colour="grey68") +
scale_fill_viridis_d(name="Level IV Ecoregions") + coord_quickmap()
if (!file.exists("./lidar_hs.tif")){
download.file(file.path('https://ortho.gis.iastate.edu/arcgis/services/ortho/lidar_hillshade_3m/ImageServer/WCSServer/lidar_hs.tif?SERVICE=WCS&VERSION=1.0.0&request=GetCoverage&COVERAGE=1&bbox=194163,4466189,744163,4841189&width=1100&HEIGHT=750&layers=lidar_hs&CRS=EPSG:26915&format=GeoTIFF'))
}
if (!file.exists("./lidar_hs.tif")){
URL      <- "https://ortho.gis.iastate.edu/arcgis/services/ortho/lidar_hillshade_3m/ImageServer/WCSServer/lidar_hs.tif?SERVICE=WCS&VERSION=1.0.0&request=GetCoverage&COVERAGE=1&bbox=194163,4466189,744163,4841189&width=1100&HEIGHT=750&layers=lidar_hs&CRS=EPSG:26915&format=GeoTIFF"
destfile <- getwd()
download.file(URL, destfile)
}
if (!file.exists("./lidar_hs.tif")){
URL      <- "https://ortho.gis.iastate.edu/arcgis/services/ortho/lidar_hillshade_3m/ImageServer/WCSServer/lidar_hs.tif?SERVICE=WCS&VERSION=1.0.0&request=GetCoverage&COVERAGE=1&bbox=194163,4466189,744163,4841189&width=1100&HEIGHT=750&layers=lidar_hs&CRS=EPSG:26915&format=GeoTIFF"
destfile <- ("./geotiff.zip")
download.file(URL, destfile,
f2 <- tempfile())
unzip(f2, exdir = getwd()) # This unzips the file to your working directory
rm(f2))
if (!file.exists("./lidar_hs.tif")){
URL      <- "https://ortho.gis.iastate.edu/arcgis/services/ortho/lidar_hillshade_3m/ImageServer/WCSServer/lidar_hs.tif?SERVICE=WCS&VERSION=1.0.0&request=GetCoverage&COVERAGE=1&bbox=194163,4466189,744163,4841189&width=1100&HEIGHT=750&layers=lidar_hs&CRS=EPSG:26915&format=GeoTIFF"
destfile <- ("./geotiff.zip")
download.file(URL, destfile)
unzip(destfile, exdir = getwd()) # This unzips the file to your working directory
rm(f2))
if (!file.exists("./lidar_hs.tif")){
URL      <- "https://ortho.gis.iastate.edu/arcgis/services/ortho/lidar_hillshade_3m/ImageServer/WCSServer/lidar_hs.tif?SERVICE=WCS&VERSION=1.0.0&request=GetCoverage&COVERAGE=1&bbox=194163,4466189,744163,4841189&width=1100&HEIGHT=750&layers=lidar_hs&CRS=EPSG:26915&format=GeoTIFF"
destfile <- ("lidar_hs.tif")
download.file(URL, destfile)
}
hillshade <- raster("lidar_hs.tif")
hillshade <- raster("./lidar_hs.tif")
if (!file.exists("./lidar_hs.tif")){
URL      <- "https://ortho.gis.iastate.edu/arcgis/services/ortho/lidar_hillshade_3m/ImageServer/WCSServer/lidar_hs.tif?SERVICE=WCS&VERSION=1.0.0&request=GetCoverage&COVERAGE=1&bbox=199163,4451189,739163,4856189&width=600&HEIGHT=450&layers=lidar_hs&CRS=EPSG:26915&format=GeoTIFF"
destfile <- ("lidar_hs.tif")
download.file(URL, destfile)
}
hillshade <- raster("./lidar_hs.tif")
hillshade <- raster("lidar_hs.tif")
if (!file.exists("./ia_tiles.shp")){
download.file(file.path('https://www.geotree.uni.edu/web/ia_tiles.zip'),
f2 <- tempfile())
unzip(f2, exdir = getwd()) # This unzips the file to your working directory
rm(f2)
}
hillshade <- raster("./ia_tiles/ia_tiles.shp")
hillshade <- readOGR("./ia_tiles/ia_tiles.shp")
plot(hillshade)
hillshade <- raster("story.tif")
plot(hillshade)
hillshade <- raster("lidar_hs.tif")
plot(hillshade)
projection(hillshade)
ggplot() + geom_raster(hillshade)
identicalCRS(hillshade, iowa.regions)
lidar <- raster("lidar_hs.tif")
plot(lidar) # We'll fix the colors later
identicalCRS(iowa.regions, lidar)
proj4string(iowa.regions)
spTransform(lidar, CRS(proj4string(iowa.regions)))
lidar.reproj <- projectRaster(lidar, crs = proj4string(iowa.regions))
crs(iowa.regions)
lidar.reproj <- projectRaster(lidar, crs = crs(iowa.regions))
projection(lidar)
plot(lidar.reproj)
lidar.nad83 <- projectRaster(lidar, crs = crs(iowa.regions))
remove(lidar.reproj)
#convert the raster to points for plotting
lidar.p <- rasterToPoints(lidar.nad83)
#Make the points a dataframe for ggplot
lidar.df <- data.frame(lidar.p)
#Make appropriate column headings
colnames(lidar.df) <- c("long", "lat", "MAP")
lidar.df$MAP[lidar.df$MAP == 0] <- NA
summary(lidar.df$MAP)
ggplot() + geom_raster(lidar.df, aes(x=long, y=lat, fill=MAP))
ggplot() + geom_raster(lidar.df, aes(x=long, y=lat, color=MAP))
ggplot() + geom_raster(lidar.df, aes(x=long, y=lat, group=group, color=MAP))
ggplot() + geom_raster(lidar.df, aes(x=long, y=lat, group=group, fill=MAP))
ggplot() + geom_raster(lidar.df, aes(x=long, y=lat, group=group, fill=MAP))
ggplot() + geom_raster(lidar.df, aes(x=long, y=lat, group=group))
library(ggplot2)
ggplot() + geom_raster(lidar.df, aes(x=long, y=lat, group=group))
ggplot(lidar.df, aes(x=long, y=lat, group=group)) + geom_raster()
ggplot(lidar.df, aes(x=long, y=lat, fill=MAP)) + geom_raster()
summary(lidar.nad83)
ggplot(lidar.df, aes(x=long, y=lat, fill=MAP)) + geom_raster() +
scale_fill_gradient2(low="#737373", mid="#bdbdbd", high="#f0f0f0", midpoint=median(MAP),
na.value = NA)
ggplot(lidar.df, aes(x=long, y=lat, fill=MAP)) + geom_raster() +
scale_fill_gradient2(low="#737373", mid="#bdbdbd", high="#f0f0f0", midpoint=median(lidar.df$MAP),
na.value = NA)
median(lidar.df$MAP)
median(lidar.df$MAP)
ggplot(lidar.df, aes(x=long, y=lat, fill=MAP), na.rm=T) + geom_raster() +
scale_fill_gradient2(low="#737373", mid="#bdbdbd", high="#f0f0f0", midpoint=median(lidar.df$MAP),
na.value = NA)
ggplot(lidar.df, aes(x=long, y=lat, fill=MAP), na.rm=T) + geom_raster() +
scale_fill_gradient2(low="#737373", mid="#bdbdbd", high="#f0f0f0", midpoint=179.8355,
na.value = NA)
ggplot(lidar.df, aes(x=long, y=lat, fill=MAP), na.rm=T) + geom_raster() +
scale_fill_gradient2(low="#737373", mid="#bdbdbd", high="#f0f0f0", midpoint=90,
na.value = NA)
ggplot(lidar.df, aes(x=long, y=lat, fill=MAP), na.rm=T) + geom_raster() +
scale_fill_gradient2(low="#737373", mid="#bdbdbd", high="#f0f0f0", midpoint=10,
na.value = NA)
ggplot(lidar.df, aes(x=long, y=lat, fill=MAP), na.rm=T) + geom_raster() +
scale_fill_gradient2(low="#737373", mid="#bdbdbd", high="#f0f0f0", midpoint=180,
na.value = NA)
ggplot(lidar.df, aes(x=long, y=lat, fill=MAP), na.rm=T) + geom_raster() +
scale_fill_gradient2(low="black", mid="#bdbdbd", high="white", midpoint=180,
na.value = NA)
ggplot(lidar.df, aes(x=long, y=lat, fill=MAP), na.rm=T) + geom_raster() +
scale_fill_gradient2(low="black", mid="#bdbdbd", high="white", midpoint=160,
na.value = NA)
ggplot(lidar.df, aes(x=long, y=lat, fill=MAP), na.rm=T) + geom_raster() +
scale_fill_gradient2(low="black", mid="#bdbdbd", high="white", midpoint=187,
na.value = NA)
ggplot(lidar.df, aes(x=long, y=lat, fill=MAP), na.rm=T) + geom_raster() +
scale_fill_gradient(low="black",high="white", na.value = NA)
ggplot(lidar.df, aes(x=long, y=lat, fill=MAP), na.rm=T) + geom_raster() +
scale_fill_gradient2(low="black", mid="#bdbdbd", high="white", midpoint=188,
na.value = NA)
# Recode 0 obs to NA (These are edges and bad returns)
lidar.df$MAP[lidar.df$MAP == 0] <- NA
summary(lidar.df)
ggplot(lidar.df, aes(x=long, y=lat, fill=MAP), na.rm=T) + geom_raster() +
scale_fill_gradient2(low="black", mid="#bdbdbd", high="white", midpoint=180,
na.value = NA)
ggplot(lidar.df, aes(x=long, y=lat, fill=MAP), na.rm=T) + geom_raster() +
scale_fill_gradient2(low="black", mid="#bdbdbd", high="white", midpoint=188,
na.value = NA)
ggplot(lidar.df, aes(x=long, y=lat, fill=MAP), na.rm=T) + geom_raster() +
scale_fill_gradient2(low="black", mid="#bdbdbd", high="white", midpoint=188.2,
na.value = NA)
ggplot(lidar.df, aes(x=long, y=lat, fill=MAP), na.rm=T) + geom_raster() +
scale_fill_gradient2(low="black", mid="#bdbdbd", high="white", midpoint=170,
na.value = NA)
ggplot(lidar.df, aes(x=long, y=lat, fill=MAP), na.rm=T) + geom_raster() +
scale_fill_gradient2(low="black", mid="black", high="white", midpoint=170,
na.value = NA)
ggplot(lidar.df, aes(x=long, y=lat, fill=MAP), na.rm=T) + geom_raster() +
scale_fill_gradient2(low="black", mid="black", high="white", midpoint=180,
na.value = NA)
ggplot(lidar.df, aes(x=long, y=lat, fill=MAP), na.rm=T) + geom_raster() +
scale_fill_gradient2(low="black", mid="gray15", high="white", midpoint=180,
na.value = NA)
ggplot(lidar.df, aes(x=long, y=lat, fill=MAP), na.rm=T) + geom_raster() +
scale_fill_gradient2(low="black", mid="gray25", high="white", midpoint=180,
na.value = NA)
ggplot(lidar.df, aes(x=long, y=lat, fill=MAP), na.rm=T) + geom_raster() +
scale_fill_gradient2(low="black", mid="gray45", high="white", midpoint=180,
na.value = NA)
ggplot(lidar.df, aes(x=long, y=lat, fill=MAP), na.rm=T) + geom_raster() +
scale_fill_gradient2(low="black", mid="gray35", high="gray65", midpoint=180,
na.value = NA)
setwd("~/Research/Sites/hannahcarroll.github.io/CV")
setwd("~/Research/Sites/hannahcarroll.github.io")
setwd("~/Research/Sites/hannahcarroll.github.io/CV")
unlink('testcv_cache', recursive = TRUE)
unlink('testcv_cache', recursive = TRUE)
5000+1500+750+2000+1000+500
unlink('testcv_cache', recursive = TRUE)
unlink('testcv_cache', recursive = TRUE)
unlink('testcv_cache', recursive = TRUE)
unlink('testcv_cache', recursive = TRUE)
10750+3051+5790
